<!-- 模板元编程 Boost::MPL的排序实现 -->

## 前言

完成了前面三个模板元编程的排序以后，开始对Boost的MPL库感兴趣了，于是便使用MPL重新实现了一下那三个排序算法，选择排序、快速排序、堆排序。

时间上来说和之前差不多，堆排序花了我大部分的时间。最简单是应该就是选择排序了，只使用了一个类就实现了。

## 使用感悟

Boost::MPL大大简化了元编程的难度，它实现了大部分的算法，特别是向量（vector）的操作，是模仿std::vector，也有对应的迭代类型。有两种控制结构，判断和循环，其中判断结构和之前的差不多。但是循环结构有很大的不同，其实现的是函数式编程里面常用的折叠（fold）。

函数的调用比较有规律，基本上都是多个输入对应一个输出。使用方法都是

```C++
typedef typename boost::mpl::func<argv1, argv2>::type output_type;
```

所有的结构都有`::type`，如果是基本类型，则返回当前值，所以在使用分支结构时可以肆无忌惮的利用惰性加载功能。

## 实现

源代码： https://github.com/ink19/boost_mpl_sort

博客原文：https://www.cnblogs.com/ink19/p/boost_mpl_sort.html
